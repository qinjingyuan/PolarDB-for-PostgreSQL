import{_ as c,M as i,p as s,q as p,N as o,R as e,V as a,t as l,a1 as _}from"./framework-de73eade.js";const u="/PolarDB-for-PostgreSQL/assets/online_promote_postmaster-92e1fd76.png",g="/PolarDB-for-PostgreSQL/assets/online_promote_startup-b84a6f37.png",m="/PolarDB-for-PostgreSQL/assets/online_promote_logindex_bgw-d9f46b31.png",h={},P=e("h1",{id:"只读节点-online-promote",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#只读节点-online-promote","aria-hidden":"true"},"#"),l(" 只读节点 Online Promote")],-1),L={class:"table-of-contents"},O=_(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>PolarDB 是基于共享存储的一写多读架构，与传统数据库的主备架构有所不同：</p><ul><li><strong>Standby 节点</strong>，是传统数据库的备库节点，有独立的存储，与主库节点之间通过传输完整的 WAL 日志来同步数据；</li><li><strong>只读节点</strong>，也称为 <strong>Replica 节点</strong>，是 PolarDB 数据库的只读备库节点，与主节点共享同一份存储，与主库节点之间通过传输 WAL Meta 日志信息来同步数据。</li></ul><p>传统数据库支持 Standby 节点升级为主库节点的 Promote 操作，在不重启的情况下，提升备库节点为主库节点，继续提供读写服务，保证集群高可用的同时，也有效降低了实例的恢复时间 RTO。</p><p>PolarDB 同样需要只读备库节点提升为主库节点的 Promote 能力，鉴于只读节点与传统数据库 Standby 节点的不同，PolarDB 提出了一种一写多读架构下只读节点的 OnlinePromote 机制。</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><p>使用 <code>pg_ctl</code> 工具对 Replica 节点执行 Promote 操作：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>pg_ctl promote <span class="token parameter variable">-D</span> <span class="token punctuation">[</span>datadir<span class="token punctuation">]</span>
</code></pre></div><h2 id="onlinepromote-原理" tabindex="-1"><a class="header-anchor" href="#onlinepromote-原理" aria-hidden="true">#</a> OnlinePromote 原理</h2><h3 id="触发机制" tabindex="-1"><a class="header-anchor" href="#触发机制" aria-hidden="true">#</a> 触发机制</h3><p>PolarDB 使用和传统数据库一致的备库节点 Promote 方法，触发条件如下：</p><ul><li>调用 <code>pg_ctl</code> 工具的 Promote 命令，<code>pg_ctl</code> 工具会向 Postmaster 进程发送信号，接收到信号的 Postmaster 进程再通知其他进程执行相应的操作，完成整个 Promote 操作。</li><li>在 <code>recovery.conf</code> 中定义 trigger file 的路径，其他组件通过生成 trigger file 来触发。</li></ul><p>相比于传统数据库 Standby 节点的 Promote 操作，PolarDB Replica 节点的 OnlinePromote 操作需要多考虑以下几个问题：</p><ul><li>Replica 节点 OnlinePromote 为主库节点后，需要以读写模式重新挂载共享存储；</li><li>Replica 节点会在内存中维护一些重要的控制信息，这些控制信息在主库节点上会被持久化到共享存储中。Promote 过程中，这部分信息也需要持久化到共享存储；</li><li>Replica 节点在内存中通过日志回放得到的数据信息，在 OnlinePromote 的过程中需要确认哪些数据可以写入共享存储；</li><li>Replica 节点在内存中回放 WAL 日志时，缓冲区淘汰方法和不刷脏的特性与主库节点截然不同，OnlinePromote 过程中应该如何处理；</li><li>Replica 节点 OnlinePromote 过程中，各个子进程的处理过程。</li></ul><h3 id="postmaster-进程处理过程" tabindex="-1"><a class="header-anchor" href="#postmaster-进程处理过程" aria-hidden="true">#</a> Postmaster 进程处理过程</h3><ol><li>Postmaster 进程发现 trigger file 文件或者接收到 OnlinePromote 命令后，进入 OnlinePromote 的处理流程；</li><li>发送 <code>SIGTERM</code> 信号给当前所有 Backend 进程。 <ul><li>只读节点在 OnlinePromote 过程中可以继续提供只读服务，但是只读的数据不能保证是最新的。为了避免切换过程中从新的主库节点读到旧的数据，这里先将所有的 Backend 会话断开，等 Startup 进程退出后再开始对外提供读写服务。</li></ul></li><li>重新以 <strong>读写模式</strong> 挂载共享存储，需要底层存储提供相应的功能支持；</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>Startup 进程</strong>，通知其结束回放并处理 OnlinePromote 操作；</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>Polar Worker 辅助进程</strong>，通知其停止对于部分 LogIndex 数据的解析，因为这部分 LogIndex 数据只对于正常运行期间的 Replica 节点有用处。</li><li>发送 <code>SIGUSR2</code> 信号给 <strong>LogIndex BGW (Background Ground Worker) 后台回放进程</strong>，通知其处理 OnlinePromote 操作。</li></ol><p><img src="`+u+'" alt="image.png"></p><h3 id="startup-进程处理过程" tabindex="-1"><a class="header-anchor" href="#startup-进程处理过程" aria-hidden="true">#</a> Startup 进程处理过程</h3><ol><li>Startup 进程回放完所有旧主库节点产生的 WAL 日志，生成相应的 LogIndex 数据；</li><li>确认旧主库节点最后一次的 checkpoint 在 Replica 节点也完成，目的是确保对应的 checkpoint 应该在 Replica 节点本地写入的数据落盘完毕；</li><li>等待确认 LogIndex BGW 进程进入 <code>POLAR_BG_WAITING_RESET</code> 状态；</li><li>将 Replica 节点本地的数据（如 clog 等）拷贝到共享存储中；</li><li>重置 WAL Meta Queue 内存空间，从共享存储中重新加载 slot 信息，并重新设置 LogIndex BGW 进程的回放位点为其与当前一致性位点两者的最小值，表示接下来 LogIndex BGW 进程从该位点开始新的回放；</li><li>将节点角色设置为主库节点，并设置 LogIndex BGW 进程的状态为 <code>POLAR_BG_ONLINE_PROMOTE</code>，至此实例可以对外提供读写服务。</li></ol><p><img src="'+g+'" alt="image.png"></p><h3 id="logindex-bgw-进程处理过程" tabindex="-1"><a class="header-anchor" href="#logindex-bgw-进程处理过程" aria-hidden="true">#</a> LogIndex BGW 进程处理过程</h3><p>LogIndex BGW 进程有自己的状态机，在其生命周期内，一直按照该状态机运行，具体每个状态机的操作内容如下：</p><ul><li><code>POLAR_BG_WAITING_RESET</code>：LogIndex BGW 进程状态重置，通知其他进程状态机发生变化；</li><li><code>POLAR_BG_ONLINE_PROMOTE</code>：读取 LogIndex 数据，组织并分发回放任务，利用并行回放进程组回放 WAL 日志，该状态的进程需要回放完所有的 LogIndex 数据才会进行状态切换，最后推进后台回放进程的回放位点；</li><li><code>POLAR_BG_REDO_NOT_START</code>：表示回放任务结束；</li><li><code>POLAR_BG_RO_BUF_REPLAYING</code>：Replica 节点正常运行时，进程处于该状态，读取 LogIndex 数据，按照 WAL 日志的顺序回放一定量的 WAL 日志，每回放一轮，便会推进后台回放进程的回放位点；</li><li><code>POLAR_BG_PARALLEL_REPLAYING</code>：LogIndex BGW 进程每次读取一定量的 LogIndex 数据，组织并分发回放任务，利用并行回放进程组回放 WAL 日志，每回放一轮，便会推进后台回放进程的回放位点。</li></ul><p><img src="'+m+'" alt="image.png"></p><p>LogIndex BGW 进程接收到 Postmaster 的 <code>SIGUSR2</code> 信号后，执行 OnlinePromote 操作的流程如下：</p><ol><li>将所有的 LogIndex 数据落盘，并切换状态为 <code>POLAR_BG_WAITING_RESET</code>；</li><li>等待 Startup 进程将其切换为 <code>POLAR_BG_ONLINE_PROMOTE</code> 状态； <ul><li>Replica 节点在执行 OnlinePromote 操作前，后台回放进程只回放在 buffer pool 中的页面；</li><li>Replica 节点处于 OnlinePromote 过程中时，鉴于之前主库节点可能有部分页面在内存中，未来得及落盘，所以后台回放进程按照日志顺序回放所有的 WAL 日志，并在回放后调用 <code>MarkBufferDirty</code> 标记该页面为脏页，等待刷脏；</li><li>回放结束后，推进后台回放进程的回放位点，然后切换状态为 <code>POLAR_BG_REDO_NOT_START</code>。</li></ul></li></ol><h3 id="刷脏控制" tabindex="-1"><a class="header-anchor" href="#刷脏控制" aria-hidden="true">#</a> 刷脏控制</h3><p>每个脏页都带有一个 Oldest LSN，该 LSN 在 FlushList 里是有序的，目的是通过这个 LSN 来确定一致性位点。</p><p>Replica 节点在 OnlinePromote 过程后，由于同时存在着回放和新的页面写入，如果像主库节点一样，直接将当前的 WAL 日志插入位点设为 Buffer 的 Oldest LSN，可能会导致：比它小的 Buffer 还未落盘，但新的一致性位点已经被设置。</p><p>所以 Replica 节点在 OnlinePromote 过程中需要面对两个问题：</p><ul><li>旧主库节点的 WAL 日志回放时，如何给脏页设置 Oldest LSN；</li><li>新主库节点产生的脏页如何设置 Oldest LSN；</li></ul><p>PolarDB 在 Replica 节点 OnlinePromote 的过程中，将上述两类情况产生的脏页的 Oldest LSN 都设置为 LogIndex BGW 进程推进的回放位点。只有当标记为相同 Oldest LSN 的 Buffer 都落盘了，才将一致性位点向前推进。</p>',32);function f(n,R){const r=i("Badge"),d=i("ArticleInfo"),t=i("router-link");return s(),p("div",null,[P,o(r,{type:"tip",text:"V11 / v1.1.1-",vertical:"top"}),o(d,{frontmatter:n.$frontmatter},null,8,["frontmatter"]),e("nav",L,[e("ul",null,[e("li",null,[o(t,{to:"#背景"},{default:a(()=>[l("背景")]),_:1})]),e("li",null,[o(t,{to:"#使用"},{default:a(()=>[l("使用")]),_:1})]),e("li",null,[o(t,{to:"#onlinepromote-原理"},{default:a(()=>[l("OnlinePromote 原理")]),_:1}),e("ul",null,[e("li",null,[o(t,{to:"#触发机制"},{default:a(()=>[l("触发机制")]),_:1})]),e("li",null,[o(t,{to:"#postmaster-进程处理过程"},{default:a(()=>[l("Postmaster 进程处理过程")]),_:1})]),e("li",null,[o(t,{to:"#startup-进程处理过程"},{default:a(()=>[l("Startup 进程处理过程")]),_:1})]),e("li",null,[o(t,{to:"#logindex-bgw-进程处理过程"},{default:a(()=>[l("LogIndex BGW 进程处理过程")]),_:1})]),e("li",null,[o(t,{to:"#刷脏控制"},{default:a(()=>[l("刷脏控制")]),_:1})])])])])]),O])}const x=c(h,[["render",f],["__file","avail-online-promote.html.vue"]]);export{x as default};
