import{_ as d,M as t,p as i,q as u,N as n,R as a,V as l,t as e,a1 as h}from"./framework-de73eade.js";const _="/PolarDB-for-PostgreSQL/assets/bulk_read-7ba232a8.png",k="/PolarDB-for-PostgreSQL/assets/bulk_vacuum_data-f68a39eb.png",f="/PolarDB-for-PostgreSQL/assets/bulk_seq_scan-98bbf92e.png",g="/PolarDB-for-PostgreSQL/assets/bulk_insert_data-4b171395.png",S="/PolarDB-for-PostgreSQL/assets/bulk_create_index_data-9d2da036.png",B={},b=a("h1",{id:"预读-预扩展",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#预读-预扩展","aria-hidden":"true"},"#"),e(" 预读 / 预扩展")],-1),P={class:"table-of-contents"},x=a("h2",{id:"背景介绍",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#背景介绍","aria-hidden":"true"},"#"),e(" 背景介绍")],-1),m={href:"https://en.wikipedia.org/wiki/Ext4",target:"_blank",rel:"noopener noreferrer"},E=h('<h2 id="功能介绍" tabindex="-1"><a class="header-anchor" href="#功能介绍" aria-hidden="true">#</a> 功能介绍</h2><h3 id="堆表预读" tabindex="-1"><a class="header-anchor" href="#堆表预读" aria-hidden="true">#</a> 堆表预读</h3><p>在 PostgreSQL 读取堆表的过程中，会以 8kB 页为单位通过文件系统读取页面至内存缓冲池（Buffer Pool）中。PFS 对于这种数据量较小的 I/O 操作并不是特别高效。所以，PolarDB 为了适配 PFS 而设计了 <strong>堆表批量预读</strong>。当读取的页数量大于 1 时，将会触发批量预读，一次 I/O 读取 128kB 数据至 Buffer Pool 中。预读对顺序扫描（Sequential Scan）、Vacuum 两种场景性能可以带来一倍左右的提升，在索引创建场景下可以带来 18% 的性能提升。</p><h3 id="堆表预扩展" tabindex="-1"><a class="header-anchor" href="#堆表预扩展" aria-hidden="true">#</a> 堆表预扩展</h3><p>在 PostgreSQL 中，表空间的扩展过程中将会逐个申请并扩展 8kB 的页。即使是 PostgreSQL 支持的批量页扩展，进行一次 N 页扩展的流程中也包含了 N 次 I/O 操作。这种页扩展不符合 PFS 最小页扩展粒度为 4MB 的特性。为此，PolarDB 设计了堆表批量预扩展，在扩展堆表的过程中，一次 I/O 扩展 4MB 页。在写表频繁的场景下（如装载数据），能够带来一倍的性能提升。</p><h3 id="索引创建预扩展" tabindex="-1"><a class="header-anchor" href="#索引创建预扩展" aria-hidden="true">#</a> 索引创建预扩展</h3><p>索引创建预扩展与堆表预扩展的功能类似。索引创建预扩展特别针对 PFS 优化索引创建过程。在索引创建的页扩展过程中，一次 I/O 扩展 4MB 页。这种设计可以在创建索引的过程中带来 30% 的性能提升。</p><div class="custom-container warning"><p class="custom-container-title">注意</p><p>当前索引创建预扩展只适配了 B-Tree 索引。其他索引类型暂未支持。</p></div><h2 id="功能设计" tabindex="-1"><a class="header-anchor" href="#功能设计" aria-hidden="true">#</a> 功能设计</h2><h3 id="堆表预读-1" tabindex="-1"><a class="header-anchor" href="#堆表预读-1" aria-hidden="true">#</a> 堆表预读</h3><p>堆表预读的实现步骤主要分为四步：</p><ol><li>在 Buffer Pool 中申请 N 个 Buffer</li><li>通过 <code>palloc</code> 在内存中申请一段大小为 <code>N * 页大小</code> 的空间，简称为 <code>p</code></li><li>通过 PFS 批量读取堆表中 <code>N * 页大小</code> 的数据拷贝至 <code>p</code> 中</li><li>将 <code>p</code> 中 N 个页的内容逐个拷贝至从 Buffer Pool 申请的 N 个 Buffer 中。</li></ol><p>后续的读取操作会直接命中 Buffer。数据流图如下所示：</p><p><img src="'+_+`" alt="heap-read"></p><h3 id="堆表预扩展-1" tabindex="-1"><a class="header-anchor" href="#堆表预扩展-1" aria-hidden="true">#</a> 堆表预扩展</h3><p>预扩展的实现步骤主要分为三步：</p><ol><li>从 Buffer Pool 中申请 N 个 Buffer，不触发文件系统的页扩展</li><li>通过 PFS 的文件写入接口进行批量页扩展，并且写入为全零页</li><li>对申请出来的页逐个进行页初始化，标识页的可用空间，结束预扩展</li></ol><h3 id="索引创建预扩展-1" tabindex="-1"><a class="header-anchor" href="#索引创建预扩展-1" aria-hidden="true">#</a> 索引创建预扩展</h3><p>索引创建预扩展的实现步骤与预扩展类似，但没有涉及 Buffer 的申请。步骤如下：</p><ol><li>写索引页时，通过 PFS 的文件写入接口进行批量页扩展，并且写入为全零页</li><li>将 Buffer Pool 中已经构建好的索引页写入文件系统中</li></ol><h2 id="使用指南" tabindex="-1"><a class="header-anchor" href="#使用指南" aria-hidden="true">#</a> 使用指南</h2><h3 id="堆表预读-2" tabindex="-1"><a class="header-anchor" href="#堆表预读-2" aria-hidden="true">#</a> 堆表预读</h3><p>堆表预读的参数名为 <code>polar_bulk_read_size</code>，功能默认开启，默认大小为 128kB。不建议用户自行修改该参数，128kB 是贴合 PFS 的最优值，自行调整并不会带来性能的提升。</p><p>关闭功能：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_bulk_read_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打开功能并设置预读大小为 128kB：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_bulk_read_size <span class="token operator">=</span> <span class="token string">&#39;128kB&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="堆表预扩展-2" tabindex="-1"><a class="header-anchor" href="#堆表预扩展-2" aria-hidden="true">#</a> 堆表预扩展</h3><p>堆表预扩展的参数名为 <code>polar_bulk_extend_size</code>，功能默认开启，预扩展的大小默认是 4MB。不建议用户自行修改该参数值，4MB 是贴合 PFS 的最优值。</p><p>关闭功能：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_bulk_extend_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打开功能并设置预扩展大小为 4MB：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_bulk_extend_size <span class="token operator">=</span> <span class="token string">&#39;4MB&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="索引创建预扩展-2" tabindex="-1"><a class="header-anchor" href="#索引创建预扩展-2" aria-hidden="true">#</a> 索引创建预扩展</h3><p>索引创建预扩展的参数名为 <code>polar_index_create_bulk_extend_size</code>，功能默认开启。索引创建预扩展的大小默认是 4MB。不建议用户自行修改该参数值，4MB 是贴合 PFS 的最优值。</p><p>关闭功能：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_index_create_bulk_extend_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打开功能，并设置预扩展大小为 4MB：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> polar_index_create_bulk_extend_size <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> pg_reload_conf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="性能表现" tabindex="-1"><a class="header-anchor" href="#性能表现" aria-hidden="true">#</a> 性能表现</h2><p>为了展示堆表预读、堆表预扩展、索引创建预扩展的性能提升效果，我们在 PolarDB for PostgreSQL 14 的实例上进行了测试。</p><ul><li>规格：8 核 32GB 内存</li><li>测试场景：400GB pgbench 测试</li></ul><h3 id="堆表预读-3" tabindex="-1"><a class="header-anchor" href="#堆表预读-3" aria-hidden="true">#</a> 堆表预读</h3><p>400GB 表的 Vacuum 性能：</p><p><img src="`+k+'" alt="400gb-vacuum-perf"></p><p>400GB 表的 SeqScan 性能：</p><p><img src="'+f+'" alt="400gb-vacuum-seqscan"></p><p>结论：</p><ul><li>堆表预读在 Vacuum 和 SeqScan 场景上，性能提升了 1-2 倍</li><li>堆表预读大小在超过默认值 128kB 之后对性能提升没有明显帮助</li></ul><h3 id="堆表预扩展-3" tabindex="-1"><a class="header-anchor" href="#堆表预扩展-3" aria-hidden="true">#</a> 堆表预扩展</h3><p>400GB 表数据装载性能：</p><p><img src="'+g+'" alt="400gb-insert-data-perf"></p><p>结论：</p><ul><li>堆表预扩展在数据装载场景下带来一倍的性能提升</li><li>堆表预扩展大小在超过默认值 4MB 后对性能没有明显帮助</li></ul><h3 id="索引创建预扩展-3" tabindex="-1"><a class="header-anchor" href="#索引创建预扩展-3" aria-hidden="true">#</a> 索引创建预扩展</h3><p>400GB 表创建索引性能：</p><p><img src="'+S+'" alt="400GB 表创建索引性能"></p><p>结论：</p><ul><li>索引创建预扩展在索引创建场景下能够带来 30% 的性能提升</li><li>加大索引创建预扩展大小超过默认值 4MB 对性能没有明显帮助</li></ul>',59);function T(o,L){const r=t("Badge"),p=t("ArticleInfo"),s=t("router-link"),c=t("ExternalLinkIcon");return i(),u("div",null,[b,n(r,{type:"tip",text:"V11 / v1.1.1-",vertical:"top"}),n(p,{frontmatter:o.$frontmatter},null,8,["frontmatter"]),a("nav",P,[a("ul",null,[a("li",null,[n(s,{to:"#背景介绍"},{default:l(()=>[e("背景介绍")]),_:1})]),a("li",null,[n(s,{to:"#功能介绍"},{default:l(()=>[e("功能介绍")]),_:1}),a("ul",null,[a("li",null,[n(s,{to:"#堆表预读"},{default:l(()=>[e("堆表预读")]),_:1})]),a("li",null,[n(s,{to:"#堆表预扩展"},{default:l(()=>[e("堆表预扩展")]),_:1})]),a("li",null,[n(s,{to:"#索引创建预扩展"},{default:l(()=>[e("索引创建预扩展")]),_:1})])])]),a("li",null,[n(s,{to:"#功能设计"},{default:l(()=>[e("功能设计")]),_:1}),a("ul",null,[a("li",null,[n(s,{to:"#堆表预读-1"},{default:l(()=>[e("堆表预读")]),_:1})]),a("li",null,[n(s,{to:"#堆表预扩展-1"},{default:l(()=>[e("堆表预扩展")]),_:1})]),a("li",null,[n(s,{to:"#索引创建预扩展-1"},{default:l(()=>[e("索引创建预扩展")]),_:1})])])]),a("li",null,[n(s,{to:"#使用指南"},{default:l(()=>[e("使用指南")]),_:1}),a("ul",null,[a("li",null,[n(s,{to:"#堆表预读-2"},{default:l(()=>[e("堆表预读")]),_:1})]),a("li",null,[n(s,{to:"#堆表预扩展-2"},{default:l(()=>[e("堆表预扩展")]),_:1})]),a("li",null,[n(s,{to:"#索引创建预扩展-2"},{default:l(()=>[e("索引创建预扩展")]),_:1})])])]),a("li",null,[n(s,{to:"#性能表现"},{default:l(()=>[e("性能表现")]),_:1}),a("ul",null,[a("li",null,[n(s,{to:"#堆表预读-3"},{default:l(()=>[e("堆表预读")]),_:1})]),a("li",null,[n(s,{to:"#堆表预扩展-3"},{default:l(()=>[e("堆表预扩展")]),_:1})]),a("li",null,[n(s,{to:"#索引创建预扩展-3"},{default:l(()=>[e("索引创建预扩展")]),_:1})])])])])]),x,a("p",null,[e("PolarDB for PostgreSQL（以下简称 PolarDB）底层使用 PolarFS（以下简称为 PFS）作为文件系统。不同于 "),a("a",m,[e("ext4"),n(c)]),e(" 等单机文件系统，PFS 在页扩展过程中，元数据更新开销较大；且 PFS 的最小页扩展粒度为 4MB。而 PostgreSQL 8kB 的页扩展粒度并不适合 PFS，将会导致写表或创建索引时性能下降；同时，PFS 在读取大块页面时 I/O 效率更高。为了适配上述特征，我们为 PolarDB 设计了堆表预读、堆表预扩展、索引创建预扩展的功能，使运行在 PFS 上的 PolarDB 能够获得更好的性能。")]),E])}const v=d(B,[["render",T],["__file","bulk-read-and-extend.html.vue"]]);export{v as default};
